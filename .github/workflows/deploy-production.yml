name: Deploy to Production Environment

on:
  workflow_dispatch:
    inputs:
      image_tag:
        description: 'Container image tag to deploy'
        required: false
        default: ''
      run_tests:
        description: 'Run comprehensive tests after deployment'
        type: boolean
        default: true
      rollback_on_failure:
        description: 'Automatically rollback on failure'
        type: boolean
        default: true

env:
  JAVA_VERSION: '22'
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  NAMESPACE: finance-services-production
  ENVIRONMENT: production

jobs:
  # Manual approval gate for production deployment
  approval:
    name: Production Deployment Approval
    runs-on: ubuntu-latest
    environment:
      name: production-approval
    steps:
      - name: Approval notification
        run: |
          echo "Production deployment has been approved."
          echo "Proceeding with deployment to production environment."

  # Prepare for production deployment
  prepare:
    name: Prepare Production Deployment
    needs: approval
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.set-image.outputs.image_tag }}
      version: ${{ steps.set-image.outputs.version }}
      target_version: ${{ steps.set-target.outputs.target_version }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set image tag
        id: set-image
        run: |
          if [ -n "${{ github.event.inputs.image_tag }}" ]; then
            # Use manually provided image tag
            echo "Using manually provided image tag: ${{ github.event.inputs.image_tag }}"
            echo "image_tag=${{ github.event.inputs.image_tag }}" >> $GITHUB_OUTPUT
            
            # Extract version from tag
            VERSION=$(echo "${{ github.event.inputs.image_tag }}" | grep -oP 'v\d+\.\d+\.\d+' || echo "unknown")
            echo "version=${VERSION#v}" >> $GITHUB_OUTPUT
          else
            # Get latest staging tag from registry
            echo "Fetching latest staging image tag..."
            
            # Authenticate with GitHub Container Registry
            echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
            
            # Get latest tag
            LATEST_TAG="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest"
            echo "image_tag=${LATEST_TAG}" >> $GITHUB_OUTPUT
            
            # Get version from image label
            VERSION=$(docker inspect ${LATEST_TAG} --format='{{index .Config.Labels "org.opencontainers.image.version"}}' || echo "unknown")
            echo "version=${VERSION}" >> $GITHUB_OUTPUT
          fi
          
          echo "Selected image tag: $(cat $GITHUB_OUTPUT | grep image_tag | cut -d= -f2)"
          echo "Version: $(cat $GITHUB_OUTPUT | grep version | cut -d= -f2)"

      - name: Verify image exists
        run: |
          echo "Verifying image exists: ${{ steps.set-image.outputs.image_tag }}"
          docker pull ${{ steps.set-image.outputs.image_tag }} || {
            echo "::error::Image ${{ steps.set-image.outputs.image_tag }} not found in registry"
            exit 1
          }
          
      - name: Determine target version for blue-green deployment
        id: set-target
        run: |
          # In a real environment, we would check the current active version
          # For this example, we'll alternate between blue and green
          
          # Generate a random value to simulate checking current version
          RANDOM_VALUE=$((RANDOM % 2))
          
          if [ $RANDOM_VALUE -eq 0 ]; then
            echo "target_version=blue" >> $GITHUB_OUTPUT
          else
            echo "target_version=green" >> $GITHUB_OUTPUT
          fi
          
          echo "Selected target version: $(cat $GITHUB_OUTPUT | grep target_version | cut -d= -f2)"

  # Create database backup before deployment
  backup:
    name: Create Database Backup
    needs: prepare
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      # For this example, we'll simulate a database backup
      # In a real environment, you would connect to your production database
      - name: Create database backup
        run: |
          echo "Creating database backup before deployment..."
          
          # Simulate backup creation
          mkdir -p /tmp/backups
          echo "Database backup created at $(date)" > /tmp/backups/backup-${{ needs.prepare.outputs.version }}.log
          
          echo "Database backup completed successfully"
          
      - name: Upload backup artifact
        uses: actions/upload-artifact@v4
        with:
          name: database-backup-${{ needs.prepare.outputs.version }}
          path: /tmp/backups/
          retention-days: 30

  # Deploy to production environment using blue-green strategy
  deploy:
    name: Deploy to Production
    needs: [prepare, backup]
    runs-on: ubuntu-latest
    environment:
      name: production
      url: https://account-service.example.com
    permissions:
      contents: read
      packages: read
      deployments: write
    outputs:
      deployment-status: ${{ steps.deploy.outputs.status }}
      service-url: ${{ steps.deploy.outputs.service-url }}
      active-version: ${{ steps.deploy.outputs.active-version }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      # For this example, we'll use a local Kubernetes setup
      # In production, you would configure access to your actual cluster
      - name: Set up local Kubernetes (Kind)
        uses: helm/kind-action@v1.8.0
        with:
          cluster_name: production-cluster
          config: |
            kind: Cluster
            apiVersion: kind.x-k8s.io/v1alpha4
            nodes:
            - role: control-plane
              kubeadmConfigPatches:
              - |
                kind: InitConfiguration
                nodeRegistration:
                  kubeletExtraArgs:
                    node-labels: "environment=production"
              extraPortMappings:
              - containerPort: 30080
                hostPort: 8080
                protocol: TCP
              - containerPort: 30081
                hostPort: 9001
                protocol: TCP

      - name: Load Docker image to Kind
        run: |
          # Get the image tag from the prepare job
          IMAGE_TAG="${{ needs.prepare.outputs.image_tag }}"
          echo "Loading image: $IMAGE_TAG"
          
          # Pull the image
          docker pull "$IMAGE_TAG"
          
          # Load the image into Kind cluster
          kind load docker-image "$IMAGE_TAG" --name production-cluster

      - name: Create production namespace and resources
        run: |
          echo "Creating production namespace and resources..."
          
          # Apply Kubernetes manifests
          kubectl apply -f account-service/k8s/environments/production/namespace.yaml
          kubectl apply -f account-service/k8s/environments/production/configmap.yaml
          kubectl apply -f account-service/k8s/environments/production/secrets.yaml
          kubectl apply -f account-service/k8s/environments/production/postgres-deployment.yaml
          
          # Wait for database to be ready
          echo "Waiting for database to be ready..."
          kubectl wait --for=condition=ready pod -l app=postgres -n ${{ env.NAMESPACE }} --timeout=300s

      - name: Deploy using blue-green strategy
        id: deploy
        run: |
          cd account-service/k8s/environments/production
          
          # Make scripts executable
          chmod +x blue-green-switch.sh
          chmod +x health-monitor.sh
          
          # Update image tag in deployment
          IMAGE_TAG="${{ needs.prepare.outputs.image_tag }}"
          TARGET_VERSION="${{ needs.prepare.outputs.target_version }}"
          
          echo "Updating deployment files with image: $IMAGE_TAG"
          sed -i "s|ghcr.io/.*/account-service:.*|$IMAGE_TAG|g" blue-green-deployment.yaml
          
          # Apply blue-green deployment
          kubectl apply -f blue-green-deployment.yaml
          
          # Execute blue-green deployment switch
          ./blue-green-switch.sh --target $TARGET_VERSION
          
          if [ $? -eq 0 ]; then
            echo "status=success" >> $GITHUB_OUTPUT
            echo "service-url=https://account-service.example.com" >> $GITHUB_OUTPUT
            echo "active-version=$TARGET_VERSION" >> $GITHUB_OUTPUT
            echo "Production deployment successful"
          else
            echo "status=failure" >> $GITHUB_OUTPUT
            echo "Production deployment failed"
            exit 1
          fi

      - name: Start health monitoring
        if: ${{ github.event.inputs.rollback_on_failure == 'true' }}
        run: |
          cd account-service/k8s/environments/production
          
          # Start health monitoring in background
          nohup ./health-monitor.sh --interval 30 --failures 3 --error-rate 5 --response-time 500 > health-monitor.log 2>&1 &
          echo "Health monitoring started with PID $!"
          
          # Let it run for a short time to catch immediate issues
          sleep 60
          
          # Check if any rollbacks were triggered
          if grep -q "Triggering automatic rollback" health-monitor.log; then
            echo "::error::Automatic rollback triggered due to health check failures"
            cat health-monitor.log
            exit 1
          fi
          
          echo "No immediate health issues detected"

      - name: Verify Deployment Health
        run: |
          echo "Verifying deployment health..."
          
          # Get active version
          ACTIVE_VERSION="${{ steps.deploy.outputs.active-version }}"
          
          # Wait for services to be ready
          kubectl wait --for=condition=ready pod -l app=account-service,version=$ACTIVE_VERSION -n ${{ env.NAMESPACE }} --timeout=300s
          
          # Port forward for testing
          kubectl port-forward service/account-service 8080:8080 -n ${{ env.NAMESPACE }} &
          kubectl port-forward service/account-service-actuator 9001:9001 -n ${{ env.NAMESPACE }} &
          
          # Wait for port forwarding to establish
          sleep 10
          
          # Test health endpoints
          echo "Testing health endpoints..."
          curl -f http://localhost:9001/actuator/health || exit 1
          curl -f http://localhost:9001/actuator/health/liveness || exit 1
          curl -f http://localhost:9001/actuator/health/readiness || exit 1
          
          echo "Health checks passed!"

      - name: Generate Deployment Report
        if: always()
        run: |
          echo "## Production Deployment Report" >> $GITHUB_STEP_SUMMARY
          echo "| Component | Status | Details |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|--------|---------|" >> $GITHUB_STEP_SUMMARY
          echo "| Deployment | ${{ steps.deploy.outputs.status }} | Image: ${{ needs.prepare.outputs.image_tag }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Version | ${{ needs.prepare.outputs.version }} | |" >> $GITHUB_STEP_SUMMARY
          echo "| Active Version | ${{ steps.deploy.outputs.active-version }} | Blue-Green Deployment |" >> $GITHUB_STEP_SUMMARY
          echo "| Health Checks | ✅ | All endpoints responding |" >> $GITHUB_STEP_SUMMARY
          echo "| Service URL | - | ${{ steps.deploy.outputs.service-url }} |" >> $GITHUB_STEP_SUMMARY
          
          # Get pod information
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Pod Status" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          kubectl get pods -n ${{ env.NAMESPACE }} -o wide >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          
          # Get service information
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Service Status" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          kubectl get services -n ${{ env.NAMESPACE }} -o wide >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY

      - name: Upload Deployment Artifacts
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: production-deployment-logs
          path: |
            /tmp/deployment-logs/
            account-service/k8s/environments/production/health-monitor.log
          retention-days: 30

      - name: Cleanup on Failure
        if: failure()
        run: |
          echo "Cleaning up failed deployment..."
          
          # If rollback is enabled, trigger rollback
          if [ "${{ github.event.inputs.rollback_on_failure }}" == "true" ]; then
            cd account-service/k8s/environments/production
            ./blue-green-switch.sh --rollback
            echo "Rollback triggered"
          fi

  # Comprehensive testing suite for production validation
  test:
    name: Production Validation Tests
    needs: [prepare, deploy]
    if: ${{ needs.deploy.outputs.deployment-status == 'success' && (github.event.inputs.run_tests == '' || github.event.inputs.run_tests == 'true') }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up JDK ${{ env.JAVA_VERSION }}
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: 'temurin'
          cache: maven

      - name: Run Smoke Tests
        id: smoke-tests
        run: |
          echo "Running smoke tests against production environment..."
          cd account-service
          
          # Set environment variables for tests
          export SERVICE_URL=http://localhost:8080
          export ACTUATOR_URL=http://localhost:9001
          
          # Run smoke tests
          ./mvnw verify -Psmoke-tests -Dspring.profiles.active=production

      - name: Install K6 for performance testing
        run: |
          sudo gpg -k
          sudo gpg --no-default-keyring --keyring /usr/share/keyrings/k6-archive-keyring.gpg --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys C5AD17C747E3415A3642D57D77C6C491D6AC1D69
          echo "deb [signed-by=/usr/share/keyrings/k6-archive-keyring.gpg] https://dl.k6.io/deb stable main" | sudo tee /etc/apt/sources.list.d/k6.list
          sudo apt-get update
          sudo apt-get install k6

      - name: Run Performance Tests
        id: performance-tests
        run: |
          cd account-service/performance-tests
          chmod +x run-performance-tests.sh
          ./run-performance-tests.sh --environment production --threshold high
        env:
          BASE_URL: http://localhost:8080

      - name: Upload Test Results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: production-test-results
          path: |
            account-service/target/surefire-reports/
            account-service/target/failsafe-reports/
            account-service/performance-tests/results/
          retention-days: 30

      - name: Generate Test Report
        if: always()
        run: |
          echo "## Production Test Results" >> $GITHUB_STEP_SUMMARY
          echo "| Test Type | Status | Details |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|--------|---------|" >> $GITHUB_STEP_SUMMARY
          echo "| Smoke Tests | ${{ steps.smoke-tests.outcome || 'completed' }} | Verified critical functionality |" >> $GITHUB_STEP_SUMMARY
          echo "| Performance Tests | ${{ steps.performance-tests.outcome || 'completed' }} | Load testing with K6 |" >> $GITHUB_STEP_SUMMARY

  # Notification
  notify:
    name: Notify Results
    runs-on: ubuntu-latest
    needs: [deploy, test]
    if: always()
    steps:
      - name: Notify on success
        if: ${{ needs.deploy.result == 'success' && (needs.test.result == 'success' || needs.test.result == 'skipped') }}
        run: |
          echo "Production deployment completed successfully!"
          # Slack notification placeholder
          echo "Sending success notification to team..."
          
          # In a real implementation, you would use a Slack webhook:
          # curl -X POST -H 'Content-type: application/json' --data '{
          #   "text": "✅ Production deployment successful! Version: ${{ needs.prepare.outputs.version }}"
          # }' ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: Notify on failure
        if: ${{ needs.deploy.result == 'failure' || needs.test.result == 'failure' }}
        run: |
          echo "Production deployment or tests failed!"
          # Slack notification placeholder
          echo "Sending failure notification to team..."
          
          # In a real implementation, you would use a Slack webhook:
          # curl -X POST -H 'Content-type: application/json' --data '{
          #   "text": "❌ Production deployment or tests failed! Please check the logs."
          # }' ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: Update monitoring systems
        run: |
          echo "Updating monitoring systems with deployment information..."
          
          # In a real implementation, you would update your monitoring systems:
          # - Create deployment markers in Grafana/Prometheus
          # - Update service catalog
          # - Create incident if needed
          
          echo "Monitoring systems updated"