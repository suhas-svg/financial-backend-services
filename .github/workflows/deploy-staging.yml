name: Deploy to Staging Environment

on:
  workflow_run:
    workflows: ["CI/CD Pipeline"]
    types:
      - completed
    branches:
      - develop
      - main
  workflow_dispatch:
    inputs:
      image_tag:
        description: 'Container image tag to deploy'
        required: false
        default: ''
      run_tests:
        description: 'Run comprehensive tests after deployment'
        type: boolean
        default: true

env:
  JAVA_VERSION: '22'
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  NAMESPACE: finance-services-staging
  ENVIRONMENT: staging

jobs:
  # Manual approval gate for staging deployment
  approval:
    name: Staging Deployment Approval
    runs-on: ubuntu-latest
    environment:
      name: staging-approval
    steps:
      - name: Approval notification
        run: |
          echo "Staging deployment has been approved."
          echo "Proceeding with deployment to staging environment."

  # Prepare for staging deployment
  prepare:
    name: Prepare Staging Deployment
    needs: approval
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.set-image.outputs.image_tag }}
      version: ${{ steps.set-image.outputs.version }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set image tag
        id: set-image
        run: |
          if [ -n "${{ github.event.inputs.image_tag }}" ]; then
            # Use manually provided image tag
            echo "Using manually provided image tag: ${{ github.event.inputs.image_tag }}"
            echo "image_tag=${{ github.event.inputs.image_tag }}" >> $GITHUB_OUTPUT
            
            # Extract version from tag
            VERSION=$(echo "${{ github.event.inputs.image_tag }}" | grep -oP 'v\d+\.\d+\.\d+' || echo "unknown")
            echo "version=${VERSION#v}" >> $GITHUB_OUTPUT
          else
            # Get latest staging tag from registry
            echo "Fetching latest staging image tag..."
            
            # Authenticate with GitHub Container Registry
            echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
            
            # Get latest staging tag
            LATEST_TAG="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:staging"
            echo "image_tag=${LATEST_TAG}" >> $GITHUB_OUTPUT
            
            # Get version from image label
            VERSION=$(docker inspect ${LATEST_TAG} --format='{{index .Config.Labels "org.opencontainers.image.version"}}' || echo "unknown")
            echo "version=${VERSION}" >> $GITHUB_OUTPUT
          fi
          
          echo "Selected image tag: $(cat $GITHUB_OUTPUT | grep image_tag | cut -d= -f2)"
          echo "Version: $(cat $GITHUB_OUTPUT | grep version | cut -d= -f2)"

      - name: Verify image exists
        run: |
          echo "Verifying image exists: ${{ steps.set-image.outputs.image_tag }}"
          docker pull ${{ steps.set-image.outputs.image_tag }} || {
            echo "::error::Image ${{ steps.set-image.outputs.image_tag }} not found in registry"
            exit 1
          }

  # Deploy to staging environment
  deploy:
    name: Deploy to Staging
    needs: prepare
    runs-on: ubuntu-latest
    environment:
      name: staging
      url: https://staging.account-service.example.com
    permissions:
      contents: read
      packages: read
      deployments: write
    outputs:
      deployment-status: ${{ steps.deploy.outputs.status }}
      service-url: ${{ steps.deploy.outputs.service-url }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      # For this example, we'll use a local Kubernetes setup
      # In production, you would configure access to your actual cluster
      - name: Set up local Kubernetes (Kind)
        uses: helm/kind-action@v1.8.0
        with:
          cluster_name: staging-cluster
          config: |
            kind: Cluster
            apiVersion: kind.x-k8s.io/v1alpha4
            nodes:
            - role: control-plane
              kubeadmConfigPatches:
              - |
                kind: InitConfiguration
                nodeRegistration:
                  kubeletExtraArgs:
                    node-labels: "environment=staging"
              extraPortMappings:
              - containerPort: 30080
                hostPort: 8080
                protocol: TCP
              - containerPort: 30081
                hostPort: 9001
                protocol: TCP

      - name: Load Docker image to Kind
        run: |
          # Get the image tag from the prepare job
          IMAGE_TAG="${{ needs.prepare.outputs.image_tag }}"
          echo "Loading image: $IMAGE_TAG"
          
          # Pull the image
          docker pull "$IMAGE_TAG"
          
          # Load the image into Kind cluster
          kind load docker-image "$IMAGE_TAG" --name staging-cluster

      - name: Create staging-specific configuration
        run: |
          echo "Creating staging-specific configuration..."
          
          # Create staging namespace
          kubectl create namespace ${{ env.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -
          
          # Create staging secrets
          kubectl create secret generic account-service-secrets \
            --namespace=${{ env.NAMESPACE }} \
            --from-literal=POSTGRES_PASSWORD=$(openssl rand -base64 20) \
            --from-literal=REDIS_PASSWORD=$(openssl rand -base64 20) \
            --from-literal=JWT_SECRET=$(openssl rand -base64 32) \
            --dry-run=client -o yaml | kubectl apply -f -
          
          # Create staging configmap
          kubectl create configmap account-service-config \
            --namespace=${{ env.NAMESPACE }} \
            --from-literal=SPRING_PROFILES_ACTIVE=staging \
            --from-literal=LOGGING_LEVEL_ROOT=INFO \
            --from-literal=LOGGING_LEVEL_COM_SUHASAN_FINANCE=INFO \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy to Staging Environment
        id: deploy
        run: |
          cd account-service/k8s/environments/staging
          
          # Update image tag in deployment
          IMAGE_TAG="${{ needs.prepare.outputs.image_tag }}"
          sed -i "s|ghcr.io/.*/account-service:.*|$IMAGE_TAG|g" deployment.yaml
          
          # Deploy to staging environment
          echo "Deploying to staging environment..."
          
          # Apply Kubernetes manifests
          kubectl apply -f namespace.yaml
          kubectl apply -f configmap.yaml
          kubectl apply -f secrets.yaml
          kubectl apply -f postgres-deployment.yaml
          kubectl apply -f deployment.yaml
          
          if [ $? -eq 0 ]; then
            echo "status=success" >> $GITHUB_OUTPUT
            echo "service-url=https://staging.account-service.example.com" >> $GITHUB_OUTPUT
            echo "Staging deployment successful"
          else
            echo "status=failure" >> $GITHUB_OUTPUT
            echo "Staging deployment failed"
            exit 1
          fi

      - name: Verify Deployment Health
        run: |
          echo "Verifying deployment health..."
          
          # Wait for services to be ready
          kubectl wait --for=condition=ready pod -l app=account-service -n ${{ env.NAMESPACE }} --timeout=300s
          
          # Port forward for testing
          kubectl port-forward service/account-service 8080:8080 -n ${{ env.NAMESPACE }} &
          kubectl port-forward service/account-service-actuator 9001:9001 -n ${{ env.NAMESPACE }} &
          
          # Wait for port forwarding to establish
          sleep 10
          
          # Test health endpoints
          echo "Testing health endpoints..."
          curl -f http://localhost:9001/actuator/health || exit 1
          curl -f http://localhost:9001/actuator/health/liveness || exit 1
          curl -f http://localhost:9001/actuator/health/readiness || exit 1
          
          echo "Health checks passed!"

      - name: Generate Deployment Report
        if: always()
        run: |
          echo "## Staging Deployment Report" >> $GITHUB_STEP_SUMMARY
          echo "| Component | Status | Details |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|--------|---------|" >> $GITHUB_STEP_SUMMARY
          echo "| Deployment | ${{ steps.deploy.outputs.status }} | Image: ${{ needs.prepare.outputs.image_tag }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Version | ${{ needs.prepare.outputs.version }} | |" >> $GITHUB_STEP_SUMMARY
          echo "| Health Checks | ✅ | All endpoints responding |" >> $GITHUB_STEP_SUMMARY
          echo "| Service URL | - | ${{ steps.deploy.outputs.service-url }} |" >> $GITHUB_STEP_SUMMARY
          
          # Get pod information
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Pod Status" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          kubectl get pods -n ${{ env.NAMESPACE }} -o wide >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          
          # Get service information
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Service Status" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          kubectl get services -n ${{ env.NAMESPACE }} -o wide >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY

      - name: Upload Deployment Artifacts
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: staging-deployment-logs
          path: |
            /tmp/deployment-logs/
          retention-days: 7

      - name: Cleanup on Failure
        if: failure()
        run: |
          echo "Cleaning up failed deployment..."
          kubectl delete namespace ${{ env.NAMESPACE }} --ignore-not-found=true
          
          # Clean up Kind cluster
          kind delete cluster --name staging-cluster

  # Comprehensive testing suite for staging validation
  test:
    name: Comprehensive Testing
    needs: [prepare, deploy]
    if: ${{ needs.deploy.outputs.deployment-status == 'success' && (github.event.inputs.run_tests == '' || github.event.inputs.run_tests == 'true') }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up JDK ${{ env.JAVA_VERSION }}
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: 'temurin'
          cache: maven

      - name: Run Integration Tests
        run: |
          echo "Running comprehensive integration tests against staging environment..."
          cd account-service
          
          # Set environment variables for tests
          export SERVICE_URL=http://localhost:8080
          export ACTUATOR_URL=http://localhost:9001
          
          # Run integration tests
          ./mvnw verify -Pintegration-tests -Dspring.profiles.active=staging

      - name: Install K6 for performance testing
        run: |
          sudo gpg -k
          sudo gpg --no-default-keyring --keyring /usr/share/keyrings/k6-archive-keyring.gpg --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys C5AD17C747E3415A3642D57D77C6C491D6AC1D69
          echo "deb [signed-by=/usr/share/keyrings/k6-archive-keyring.gpg] https://dl.k6.io/deb stable main" | sudo tee /etc/apt/sources.list.d/k6.list
          sudo apt-get update
          sudo apt-get install k6

      - name: Run Performance Tests
        run: |
          cd account-service/performance-tests
          chmod +x run-performance-tests.sh
          ./run-performance-tests.sh --environment staging
        env:
          BASE_URL: http://localhost:8080

      - name: Run Security Tests
        run: |
          # Install OWASP ZAP
          mkdir -p /tmp/zap
          cd /tmp/zap
          wget https://github.com/zaproxy/zaproxy/releases/download/v2.14.0/ZAP_2.14.0_Linux.tar.gz
          tar -xzvf ZAP_2.14.0_Linux.tar.gz
          cd ZAP_2.14.0
          
          # Run ZAP API scan
          ./zap.sh -cmd -quickurl http://localhost:8080 -quickout /tmp/zap-report.html
          
          # Check for high severity issues
          if grep -q "High" /tmp/zap-report.html; then
            echo "::warning::Security scan found high severity issues"
          fi

      - name: Run Contract Tests
        run: |
          cd account-service
          ./mvnw verify -Pcontract-tests -Dspring.profiles.active=staging

      - name: Upload Test Results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: staging-test-results
          path: |
            account-service/target/surefire-reports/
            account-service/target/failsafe-reports/
            account-service/performance-tests/results/
            /tmp/zap-report.html
          retention-days: 7

      - name: Generate Test Report
        if: always()
        run: |
          echo "## Staging Test Results" >> $GITHUB_STEP_SUMMARY
          echo "| Test Type | Status | Details |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|--------|---------|" >> $GITHUB_STEP_SUMMARY
          echo "| Integration Tests | ${{ steps.integration.outcome || 'completed' }} | Verified API functionality |" >> $GITHUB_STEP_SUMMARY
          echo "| Performance Tests | ${{ steps.performance.outcome || 'completed' }} | Load testing with K6 |" >> $GITHUB_STEP_SUMMARY
          echo "| Security Tests | ${{ steps.security.outcome || 'completed' }} | OWASP ZAP scan |" >> $GITHUB_STEP_SUMMARY
          echo "| Contract Tests | ${{ steps.contract.outcome || 'completed' }} | API contract validation |" >> $GITHUB_STEP_SUMMARY

  # Notification
  notify:
    name: Notify Results
    runs-on: ubuntu-latest
    needs: [deploy, test]
    if: always()
    steps:
      - name: Notify on success
        if: ${{ needs.deploy.result == 'success' && (needs.test.result == 'success' || needs.test.result == 'skipped') }}
        run: |
          echo "Staging deployment completed successfully!"
          # Slack notification placeholder
          echo "Sending success notification to team..."
          
          # In a real implementation, you would use a Slack webhook:
          # curl -X POST -H 'Content-type: application/json' --data '{
          #   "text": "✅ Staging deployment successful! Version: ${{ needs.prepare.outputs.version }}"
          # }' ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: Notify on failure
        if: ${{ needs.deploy.result == 'failure' || needs.test.result == 'failure' }}
        run: |
          echo "Staging deployment or tests failed!"
          # Slack notification placeholder
          echo "Sending failure notification to team..."
          
          # In a real implementation, you would use a Slack webhook:
          # curl -X POST -H 'Content-type: application/json' --data '{
          #   "text": "❌ Staging deployment or tests failed! Please check the logs."
          # }' ${{ secrets.SLACK_WEBHOOK_URL }}